defmodule Expression.Parser do
  @moduledoc """
  Expression.Parser is responsible for accepting a string
  containing an expression and returning the abstract syntax
  tree (AST) representing the expression.

  The AST generated by this module can be evaluated by
  Expression.Eval

  # Example

    iex(1)> Expression.Parser.parse("hello @world")
    {:ok, [text: "hello ", expression: [atom: "world"]], "", %{}, {1, 0}, 12}

  """
  import NimbleParsec
  import Expression.BooleanHelpers
  import Expression.DateHelpers
  import Expression.LiteralHelpers
  import Expression.OperatorHelpers

  # literal = 1, 2.1, "three", 'four', true, false, ISO dates
  defparsec(
    :literal,
    choice([
      datetime(),
      decimal(),
      int(),
      boolean(),
      single_quoted_string(),
      double_quoted_string()
    ])
    |> unwrap_and_tag(:literal)
  )

  # atom = atom
  atom =
    ascii_string([?a..?z, ?A..?Z, ?0..?9], min: 1)
    |> ascii_string([?a..?z, ?A..?Z, ?0..?9, ?_, ?-], min: 0)
    |> map({String, :downcase, []})
    |> reduce({Enum, :join, []})

  range =
    int()
    |> ignore(string(".."))
    |> concat(int())
    |> optional(
      ignore(string("//"))
      |> concat(int())
    )
    |> tag(:range)

  ignore_surrounding_whitespace = fn p ->
    ignore(optional(string(" ")))
    |> concat(p)
    |> ignore(optional(string(" ")))
  end

  # argument separator = ", "
  argument_separator =
    string(",")
    |> ignore_surrounding_whitespace.()

  lambda_capture =
    ignore(string("&"))
    |> concat(int())
    |> unwrap_and_tag(:capture)

  # arguments = expression "," expression
  defparsec(
    :arguments,
    parsec(:aexpr)
    |> optional(ignore(argument_separator) |> parsec(:arguments))
  )

  defparsec(
    :aexpr_factor,
    choice([
      lambda_capture,
      range,
      parsec(:lambda),
      parsec(:literal),
      parsec(:function),
      parsec(:variable),
      ignore(string("(")) |> parsec(:aexpr) |> ignore(string(")"))
      # parsec(:list)
    ])
    |> ignore_surrounding_whitespace.()
  )

  # defparsec(
  #   :attribute,
  #   empty()
  #   |> ascii_char([?.])
  #   |> replace(:.)
  #   |> label(".")
  # )

  defparsec(
    :key,
    ascii_char([91])
    |> debug()
    |> replace(:access)
    |> parsec(:aexpr)
    |> ignore(ascii_char([93]))
    |> label("[..]")
    |> tag(:key)
  )

  defparsec(
    :key_open,
    ascii_char([91])
    |> replace(:"#")
    |> label("[")
  )

  defparsec(
    :key_close,
    ascii_char([93])
    |> replace(:"]")
    |> label("]")
  )

  defparsec(
    :attribute,
    ascii_char([?.])
    |> replace(:.)
    |> label(".")
  )

  defparsec(
    :aexpr_attribute_or_access,
    repeat(
      choice([
        optional(parsec(:aexpr_factor))
        |> parsec(:key_open)
        |> parsec(:aexpr_attribute_or_access)
        |> parsec(:key_close)
        |> debug(),
        # |> ignore(parsec(:key_close))
        # |> reduce(:fold_infixl),
        parsec(:aexpr_factor)
        |> parsec(:attribute)
        |> parsec(:aexpr_attribute_or_access)
        |> debug()
        |> reduce(:fold_infixl),
        parsec(:aexpr_factor)
      ])
    )
    # parsec(:aexpr_factor)
    # |> repeat(
    #   choice([
    #     parsec(:key),
    #     parsec(:attribute)
    #   ])
    #   |> parsec(:aexpr_factor)
    # )
    # |> reduce(:fold_infixl)
  )

  defparsec(
    :aexpr_exponent,
    parsec(:aexpr_attribute_or_access)
    |> repeat(
      exponent()
      |> parsec(:aexpr_attribute_or_access)
    )
    |> reduce(:fold_infixl)
  )

  defparsec(
    :aexpr_term,
    parsec(:aexpr_exponent)
    |> repeat(choice([times(), divide()]) |> parsec(:aexpr_exponent))
    |> reduce(:fold_infixl)
  )

  defparsec(
    :aexpr,
    parsec(:aexpr_term)
    |> repeat(
      choice([
        plus(),
        minus(),
        concatenate(),
        gte(),
        lte(),
        neq(),
        gt(),
        lt(),
        eq()
      ])
      |> parsec(:aexpr_term)
    )
    |> reduce(:fold_infixl)
  )

  def fold_infixl(acc) do
    acc
    |> Enum.reverse()
    |> Enum.chunk_every(2)
    |> List.foldr([], fn
      [l], [] -> l
      [r, op], l -> {op, [l, r]}
    end)
  end

  # defparsec(
  #   :list,
  #   ignore(string("["))
  #   |> optional(parsec(:arguments) |> tag(:args))
  #   |> ignore(string("]"))
  #   |> tag(:list)
  # )

  # function  = "(" arguments ")"
  defparsec(
    :function,
    atom
    |> unwrap_and_tag(:name)
    |> ignore(string("("))
    |> optional(parsec(:arguments) |> tag(:args))
    |> ignore(string(")"))
    |> tag(:function)
  )

  defparsec(
    :lambda,
    ignore(string("&"))
    |> optional(parsec(:arguments) |> tag(:args))
    |> tag(:lambda)
  )

  # variable = atom
  defparsec(
    :variable,
    atom
    |> unwrap_and_tag(:atom)
  )

  expression_block =
    ignore(string("@"))
    |> lookahead_not(string("@"))
    |> ignore(string("("))
    |> parsec(:aexpr)
    |> ignore(string(")"))
    |> tag(:expression)

  expression =
    ignore(string("@"))
    |> lookahead_not(string("@"))
    |> repeat(
      choice([
        # parsec(:list),
        parsec(:function),
        parsec(:variable)
      ])
    )
    |> reduce(:fold_infixl)
    |> tag(:expression)

  escaped_at =
    ignore(string("@"))
    |> string("@")
    |> unwrap_and_tag(:text)

  text =
    empty()
    |> lookahead_not(string("@"))
    |> utf8_string([], 1)
    |> times(min: 1)
    |> reduce({Enum, :join, []})
    |> unwrap_and_tag(:text)

  defparsec(:parse, repeat(choice([expression_block, expression, escaped_at, text])))
end
